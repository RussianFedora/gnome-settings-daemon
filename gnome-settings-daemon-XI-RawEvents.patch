From b9294f2369f53efd9a60041aebf5adff8eb03597 Mon Sep 17 00:00:00 2001
From: Rui Matos <tiagomatos@gmail.com>
Date: Sun, 7 Oct 2012 21:34:35 +0200
Subject: [PATCH] keyboard: Switch gsd-input-sources-switcher to use XI
 RawEvents

XI RawEvents are delivered even while there are grabs in place by
other clients. This feature allows us to switch input sources even on
the gnome-shell's overview or the lock screen which brings us back
closer to how layout switching worked in GNOME < 3.6 .

https://bugzilla.gnome.org/show_bug.cgi?id=685676
---
 configure.ac                                  |   7 +
 plugins/keyboard/Makefile.am                  |   6 +-
 plugins/keyboard/gsd-input-sources-switcher.c | 733 +++++++++++---------------
 3 files changed, 324 insertions(+), 422 deletions(-)

diff --git a/configure.ac b/configure.ac
index fa1f131..ae6872e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -186,6 +186,13 @@ AM_CONDITIONAL(HAVE_IBUS, test "x$enable_ibus" == "xyes")
 
 PKG_CHECK_MODULES(KEYBOARD, xkbfile $IBUS_MODULE gnome-desktop-3.0 >= $GNOME_DESKTOP_REQUIRED_VERSION)
 
+PKG_CHECK_MODULES(INPUT_SOURCES_SWITCHER,
+        gdk-3.0 >= $GTK_REQUIRED_VERSION
+        gio-2.0 >= $GIO_REQUIRED_VERSION
+        x11
+        xi
+)
+
 dnl ---------------------------------------------------------------------------
 dnl - Housekeeping plugin stuff
 dnl ---------------------------------------------------------------------------
diff --git a/plugins/keyboard/Makefile.am b/plugins/keyboard/Makefile.am
index 9c5f395..1e2677c 100644
--- a/plugins/keyboard/Makefile.am
+++ b/plugins/keyboard/Makefile.am
@@ -84,18 +84,16 @@ gsd_input_sources_switcher_SOURCES = 	\
 
 gsd_input_sources_switcher_CPPFLAGS =	\
 	-I$(top_srcdir)/data		\
-	-I$(top_srcdir)/plugins/common	\
 	$(AM_CPPFLAGS)			\
 	$(NULL)
 
 gsd_input_sources_switcher_CFLAGS =	\
-	$(SETTINGS_PLUGIN_CFLAGS)	\
+	$(INPUT_SOURCES_SWITCHER_CFLAGS)\
 	$(AM_CFLAGS)			\
 	$(NULL)
 
 gsd_input_sources_switcher_LDADD  = 	\
-	$(top_builddir)/plugins/common/libcommon.la	\
-	$(SETTINGS_PLUGIN_LIBS)		\
+	$(INPUT_SOURCES_SWITCHER_LIBS)	\
 	$(NULL)
 
 EXTRA_DIST = 			\
diff --git a/plugins/keyboard/gsd-input-sources-switcher.c b/plugins/keyboard/gsd-input-sources-switcher.c
index cff2359..37b4d71 100644
--- a/plugins/keyboard/gsd-input-sources-switcher.c
+++ b/plugins/keyboard/gsd-input-sources-switcher.c
@@ -19,14 +19,12 @@
  * 02110-1301, USA.
  */
 
-#include <gtk/gtk.h>
-#include <gdk/gdkkeysyms.h>
+#include <gdk/gdk.h>
 #include <gdk/gdkx.h>
-
 #include <X11/XKBlib.h>
+#include <X11/extensions/XInput2.h>
 
 #include "gsd-enums.h"
-#include "gsd-keygrab.h"
 
 #define GNOME_DESKTOP_INPUT_SOURCES_DIR "org.gnome.desktop.input-sources"
 #define KEY_CURRENT_INPUT_SOURCE "current"
@@ -35,12 +33,27 @@
 #define GSD_KEYBOARD_DIR "org.gnome.settings-daemon.peripherals.keyboard"
 #define KEY_SWITCHER "input-sources-switcher"
 
-static GSettings *input_sources_settings;
+/* We don't have keybindings with more than MAX_KEYS. */
+#define MAX_KEYS 2
+
+static GMainLoop *main_loop = NULL;
+
+static GSettings *input_sources_settings = NULL;
 
-static Key *the_keys = NULL;
+/* Each element in this array represents one keysym of a keybinding
+   and tells us whether that keysym is pressed or not. */
+static gboolean keys_state[MAX_KEYS] = { 0 };
+
+/* Since several keycodes may yield the same keysym we store a map of
+   keycodes to the respective toggle boolean in keys_state for the
+   respective keysym. */
+static GHashTable *keycodes = NULL;
+
+/* Number of different keysyms in a keybinding: 1..MAX_KEYS */
 static guint n_keys = 0;
 
-static guint master_keyboard_id = 0;
+/* Total number of buttons and keys pressed. */
+static guint total_pressed = 0;
 
 static gboolean includes_caps = FALSE;
 
@@ -50,8 +63,6 @@ do_switch (void)
   GVariant *sources;
   gint i, n;
 
-  /* FIXME: this is racy with the g-s-d media-keys plugin. Instead we
-     should have a DBus API on g-s-d and poke it from here.*/
   sources = g_settings_get_value (input_sources_settings, KEY_INPUT_SOURCES);
 
   n = g_variant_n_children (sources);
@@ -69,531 +80,417 @@ do_switch (void)
 }
 
 static void
-init_keys (void)
+get_keys (GdkKeymap  *keymap,
+          guint     **keysyms)
+{
+  GdkKeymapKey *keys;
+  guint keysym;
+  gint k, i, n;
+
+  while (*keysyms)
+    {
+      n_keys += 1;
+      g_assert (n_keys <= MAX_KEYS);
+
+      for (k = 0; (keysym = (*keysyms)[k]); ++k)
+        {
+          n = 0;
+          gdk_keymap_get_entries_for_keyval (keymap, keysym, &keys, &n);
+
+          for (i = 0; i < n; ++i)
+            g_hash_table_insert (keycodes, GINT_TO_POINTER (keys[i].keycode), &keys_state[n_keys - 1]);
+
+          g_free (keys);
+        }
+
+      keysyms += 1;
+    }
+}
+
+static gboolean
+init_keys (GdkKeymap *keymap)
 {
   GSettings *settings;
 
-  settings = g_settings_new (GSD_KEYBOARD_DIR);
+  if (!keycodes)
+    keycodes = g_hash_table_new (g_direct_hash, g_direct_equal);
+  else
+    g_hash_table_remove_all (keycodes);
 
+  n_keys = 0;
+
+  settings = g_settings_new (GSD_KEYBOARD_DIR);
   switch (g_settings_get_enum (settings, KEY_SWITCHER))
     {
     case GSD_INPUT_SOURCES_SWITCHER_SHIFT_L:
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Shift_L, 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_L:
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Alt_L;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Alt_L , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_L:
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Control_L;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Control_L , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_SHIFT_R:
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_R;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Shift_R , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_R:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Alt_R;
-      the_keys[0].state = 0;
-      the_keys[1].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[1].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_R:
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Control_R;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Control_R , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_SHIFT_L:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Alt_L;
-      the_keys[1].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Alt_L , 0 };
+        guint key2[] = { GDK_KEY_Shift_L, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_SHIFT_R:
-      n_keys = 4;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_R;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Alt_R;
-      the_keys[1].state = GDK_SHIFT_MASK;
-      the_keys[2].keysym = GDK_KEY_Shift_R;
-      the_keys[2].state = GDK_MOD5_MASK;
-      the_keys[3].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[3].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift , 0 };
+        guint key2[] = { GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_SHIFT_L:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = GDK_CONTROL_MASK;
-      the_keys[1].keysym = GDK_KEY_Control_L;
-      the_keys[1].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Control_L , 0 };
+        guint key2[] = { GDK_KEY_Shift_L, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_SHIFT_R:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_R;
-      the_keys[0].state = GDK_CONTROL_MASK;
-      the_keys[1].keysym = GDK_KEY_Control_R;
-      the_keys[1].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Control_R , 0 };
+        guint key2[] = { GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_SHIFT_L_SHIFT_R:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = GDK_SHIFT_MASK;
-      the_keys[1].keysym = GDK_KEY_Shift_R;
-      the_keys[1].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Shift_L , 0 };
+        guint key2[] = { GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_L_ALT_R:
-      n_keys = 4;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Alt_L;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Alt_R;
-      the_keys[1].state = GDK_MOD1_MASK;
-      the_keys[2].keysym = GDK_KEY_Alt_L;
-      the_keys[2].state = GDK_MOD5_MASK;
-      the_keys[3].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[3].state = GDK_MOD1_MASK;
+      {
+        guint key1[] = { GDK_KEY_Alt_L , 0 };
+        guint key2[] = { GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_L_CTRL_R:
-      n_keys = 2;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Control_L;
-      the_keys[0].state = GDK_CONTROL_MASK;
-      the_keys[1].keysym = GDK_KEY_Control_R;
-      the_keys[1].state = GDK_CONTROL_MASK;
+      {
+        guint key1[] = { GDK_KEY_Control_L , 0 };
+        guint key2[] = { GDK_KEY_Control_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_SHIFT:
-      n_keys = 7;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Shift_L;
-      the_keys[1].state = GDK_MOD5_MASK;
-      the_keys[2].keysym = GDK_KEY_Shift_R;
-      the_keys[2].state = GDK_MOD1_MASK;
-      the_keys[3].keysym = GDK_KEY_Shift_R;
-      the_keys[3].state = GDK_MOD5_MASK;
-      the_keys[4].keysym = GDK_KEY_Alt_L;
-      the_keys[4].state = GDK_SHIFT_MASK;
-      the_keys[5].keysym = GDK_KEY_Alt_R;
-      the_keys[5].state = GDK_SHIFT_MASK;
-      the_keys[6].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[6].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Alt_L , GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift, 0 };
+        guint key2[] = { GDK_KEY_Shift_L, GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_SHIFT:
-      n_keys = 4;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Shift_L;
-      the_keys[0].state = GDK_CONTROL_MASK;
-      the_keys[1].keysym = GDK_KEY_Shift_R;
-      the_keys[1].state = GDK_CONTROL_MASK;
-      the_keys[2].keysym = GDK_KEY_Control_L;
-      the_keys[2].state = GDK_SHIFT_MASK;
-      the_keys[3].keysym = GDK_KEY_Control_R;
-      the_keys[3].state = GDK_SHIFT_MASK;
+      {
+        guint key1[] = { GDK_KEY_Control_L , GDK_KEY_Control_R, 0 };
+        guint key2[] = { GDK_KEY_Shift_L, GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_CTRL:
-      n_keys = 7;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Control_L;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Control_L;
-      the_keys[1].state = GDK_MOD5_MASK;
-      the_keys[2].keysym = GDK_KEY_Control_R;
-      the_keys[2].state = GDK_MOD1_MASK;
-      the_keys[3].keysym = GDK_KEY_Control_R;
-      the_keys[3].state = GDK_MOD5_MASK;
-      the_keys[4].keysym = GDK_KEY_Alt_L;
-      the_keys[4].state = GDK_CONTROL_MASK;
-      the_keys[5].keysym = GDK_KEY_Alt_R;
-      the_keys[5].state = GDK_CONTROL_MASK;
-      the_keys[6].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[6].state = GDK_CONTROL_MASK;
+      {
+        guint key1[] = { GDK_KEY_Alt_L , GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift, 0 };
+        guint key2[] = { GDK_KEY_Control_L , GDK_KEY_Control_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CAPS:
-      includes_caps = TRUE;
-      n_keys = 1;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Caps_Lock;
-      the_keys[0].state = 0;
+      {
+        guint key1[] = { GDK_KEY_Caps_Lock , 0 };
+        guint *keysyms[] = { key1, NULL };
+        get_keys (keymap, keysyms);
+        includes_caps = TRUE;
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_SHIFT_CAPS:
-      includes_caps = TRUE;
-      n_keys = 3;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Caps_Lock;
-      the_keys[0].state = GDK_SHIFT_MASK;
-      the_keys[1].keysym = GDK_KEY_Shift_L;
-      the_keys[1].state = GDK_LOCK_MASK;
-      the_keys[2].keysym = GDK_KEY_Shift_R;
-      the_keys[2].state = GDK_LOCK_MASK;
+      {
+        guint key1[] = { GDK_KEY_Caps_Lock, 0 };
+        guint key2[] = { GDK_KEY_Shift_L , GDK_KEY_Shift_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+        includes_caps = TRUE;
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_ALT_CAPS:
-      includes_caps = TRUE;
-      n_keys = 5;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Caps_Lock;
-      the_keys[0].state = GDK_MOD1_MASK;
-      the_keys[1].keysym = GDK_KEY_Caps_Lock;
-      the_keys[1].state = GDK_MOD5_MASK;
-      the_keys[2].keysym = GDK_KEY_Alt_L;
-      the_keys[2].state = GDK_LOCK_MASK;
-      the_keys[3].keysym = GDK_KEY_Alt_R;
-      the_keys[3].state = GDK_LOCK_MASK;
-      the_keys[4].keysym = GDK_KEY_ISO_Level3_Shift;
-      the_keys[4].state = GDK_LOCK_MASK;
+      {
+        guint key1[] = { GDK_KEY_Caps_Lock, 0 };
+        guint key2[] = { GDK_KEY_Alt_L , GDK_KEY_Alt_R, GDK_KEY_ISO_Level3_Shift, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+        includes_caps = TRUE;
+      }
       break;
-
     case GSD_INPUT_SOURCES_SWITCHER_CTRL_CAPS:
-      includes_caps = TRUE;
-      n_keys = 3;
-      the_keys = g_new0 (Key, n_keys);
-
-      the_keys[0].keysym = GDK_KEY_Caps_Lock;
-      the_keys[0].state = GDK_CONTROL_MASK;
-      the_keys[1].keysym = GDK_KEY_Control_L;
-      the_keys[1].state = GDK_LOCK_MASK;
-      the_keys[2].keysym = GDK_KEY_Control_R;
-      the_keys[2].state = GDK_LOCK_MASK;
+      {
+        guint key1[] = { GDK_KEY_Caps_Lock, 0 };
+        guint key2[] = { GDK_KEY_Control_L , GDK_KEY_Control_R, 0 };
+        guint *keysyms[] = { key1, key2, NULL };
+        get_keys (keymap, keysyms);
+        includes_caps = TRUE;
+      }
       break;
     }
-
   g_object_unref (settings);
-}
-
-static void
-free_keys (void)
-{
-  gint i;
 
-  for (i = 0; i < n_keys; ++i)
-    g_free (the_keys[i].keycodes);
+  if (n_keys == 0)
+    {
+      g_warning ("No shortcut defined, exiting");
+      return FALSE;
+    }
 
-  g_free (the_keys);
+  return TRUE;
 }
 
-static gboolean
-match_caps_locked (const Key     *key,
-                   XIDeviceEvent *xev)
+static void
+clear_state (void)
 {
-  if (key->state & xev->mods.effective &&
-      key->keysym == XkbKeycodeToKeysym (xev->display, xev->detail, 0, 0))
-    return TRUE;
-
-  return FALSE;
+  guint i;
+  for (i = 0; i < n_keys; ++i)
+    keys_state[i] = FALSE;
 }
 
-static gboolean
-match_modifier (const Key *key,
-                XIEvent   *xiev)
+static guint
+count_pressed (void)
 {
-  Key meta;
-
-  /* When the grab is established with Caps Lock as the modifier
-     (i.e. key->state == GDK_LOCK_MASK) we can't use match_xi2_key()
-     as this modifier is black listed there, so we do the match
-     ourselves. */
-  if (key->state == GDK_LOCK_MASK)
-    return match_caps_locked (key, (XIDeviceEvent *) xiev);
-
-  meta = *key;
-
-  switch (key->keysym)
-    {
-    case GDK_KEY_Shift_L:
-    case GDK_KEY_Shift_R:
-      if (xiev->evtype == XI_KeyRelease)
-        meta.state |= GDK_SHIFT_MASK;
-      break;
-
-    case GDK_KEY_Control_L:
-    case GDK_KEY_Control_R:
-      if (xiev->evtype == XI_KeyRelease)
-        meta.state |= GDK_CONTROL_MASK;
-      break;
-
-    case GDK_KEY_ISO_Level3_Shift:
-      if (xiev->evtype == XI_KeyRelease)
-        meta.state |= GDK_MOD5_MASK;
-      break;
-
-    case GDK_KEY_Alt_L:
-    case GDK_KEY_Alt_R:
-      if (key->state == GDK_SHIFT_MASK)
-        meta.keysym = key->keysym == GDK_KEY_Alt_L ? GDK_KEY_Meta_L : GDK_KEY_Meta_R;
-
-      if (xiev->evtype == XI_KeyRelease)
-        meta.state |= GDK_MOD1_MASK;
-      break;
-    }
-
-  return match_xi2_key (&meta, (XIDeviceEvent *) xiev);
+  guint i, n;
+  n = 0;
+  for (i = 0; i < n_keys; ++i)
+    if (keys_state[i])
+      n += 1;
+  return n;
 }
 
-static gboolean
-matches_key (XIEvent *xiev)
+static void
+track_total_pressed (int evtype)
 {
-  gint i;
-
-  for (i = 0; i < n_keys; ++i)
-    if (match_modifier (&the_keys[i], xiev))
-      return TRUE;
-
-  return FALSE;
+  if (evtype == XI_RawKeyPress ||
+      evtype == XI_RawButtonPress)
+    total_pressed += 1;
+  else if (total_pressed > 0)
+    total_pressed -= 1;
 }
 
-/* Owen magic, ported to XI2 */
 static GdkFilterReturn
 filter (XEvent   *xevent,
         GdkEvent *event,
         gpointer  data)
 {
   XIEvent *xiev;
-  XIDeviceEvent *xev;
-  XIGrabModifiers mods;
-  XIEventMask evmask;
-  unsigned char mask[(XI_LASTEVENT + 7)/8] = { 0 };
+  XIRawEvent *xev;
+  gboolean *state;
+  guint old_pressed;
+  guint new_pressed;
 
   if (xevent->type != GenericEvent)
     return GDK_FILTER_CONTINUE;
 
   xiev = (XIEvent *) xevent->xcookie.data;
 
-  if (xiev->evtype != XI_ButtonPress &&
-      xiev->evtype != XI_KeyPress &&
-      xiev->evtype != XI_KeyRelease)
+  if (xiev->evtype == XI_RawButtonPress ||
+      xiev->evtype == XI_RawButtonRelease)
+    {
+      track_total_pressed (xiev->evtype);
+      clear_state ();
+      return GDK_FILTER_CONTINUE;
+    }
+
+  if (xiev->evtype != XI_RawKeyPress &&
+      xiev->evtype != XI_RawKeyRelease)
     return GDK_FILTER_CONTINUE;
 
-  xev = (XIDeviceEvent *) xiev;
+  track_total_pressed (xiev->evtype);
 
-  mods.modifiers = XIAnyModifier;
-  XISetMask (mask, XI_ButtonPress);
-  evmask.deviceid = XIAllMasterDevices;
-  evmask.mask_len = sizeof (mask);
-  evmask.mask = mask;
+  xev = (XIRawEvent *) xiev;
 
-  if (xiev->evtype != XI_ButtonPress &&
-      matches_key (xiev))
+  state = g_hash_table_lookup (keycodes, GINT_TO_POINTER (xev->detail));
+  if (!state)
     {
-      if (xiev->evtype == XI_KeyPress)
-        {
-          if (includes_caps)
-            {
-              do_switch ();
-              XIUngrabDevice (xev->display,
-                              master_keyboard_id,
-                              xev->time);
-              XkbLockModifiers (xev->display, XkbUseCoreKbd, LockMask, 0);
-            }
-          else
-            {
-              XIAllowEvents (xev->display,
-                             xev->deviceid,
-                             XISyncDevice,
-                             xev->time);
-              XIGrabButton (xev->display,
-                            XIAllMasterDevices,
-                            XIAnyButton,
-                            xev->root,
-                            None,
-                            GrabModeSync,
-                            GrabModeSync,
-                            False,
-                            &evmask,
-                            1,
-                            &mods);
-            }
-        }
-      else
-        {
-          do_switch ();
-          XIUngrabDevice (xev->display,
-                          master_keyboard_id,
-                          xev->time);
-          XIUngrabButton (xev->display,
-                          XIAllMasterDevices,
-                          XIAnyButton,
-                          xev->root,
-                          1,
-                          &mods);
-        }
+      clear_state ();
+      return GDK_FILTER_CONTINUE;
     }
+
+  old_pressed = count_pressed ();
+
+  if (xiev->evtype == XI_RawKeyPress)
+    *state = TRUE;
   else
+    *state = FALSE;
+
+  new_pressed = count_pressed ();
+
+  if (new_pressed != total_pressed)
     {
-      XIAllowEvents (xev->display,
-                     xev->deviceid,
-                     XIReplayDevice,
-                     xev->time);
-      XIUngrabDevice (xev->display,
-                      master_keyboard_id,
-                      xev->time);
-      XIUngrabButton (xev->display,
-                      XIAllMasterDevices,
-                      XIAnyButton,
-                      xev->root,
-                      1,
-                      &mods);
+      /* We don't want to trigger in case any buttons or keys were
+         already pressed. */
+      return GDK_FILTER_CONTINUE;
+    }
+
+  if (old_pressed == n_keys &&
+      new_pressed == n_keys - 1 &&
+      !includes_caps)
+    {
+      do_switch();
+    }
+  else if (new_pressed == n_keys &&
+           includes_caps)
+    {
+      /* For Caps Lock we can trigger as soon as we have all keysyms
+         pressed since applications don't generally use Caps Lock for
+         their own purposes. */
+      do_switch();
+      /* Undo the Caps Lock */
+      XkbLockModifiers (xiev->display, XkbUseCoreKbd, LockMask, 0);
     }
 
   return GDK_FILTER_CONTINUE;
 }
 
 static void
-grab_key (Key        *key,
-          GdkDisplay *display,
-          GSList     *screens)
+keys_changed (GdkKeymap *keymap)
 {
-  GdkKeymapKey *keys;
-  gboolean has_entries;
-  GArray *keycodes;
-  gint n, i;
-
-  has_entries = gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (),
-                                                   key->keysym,
-                                                   &keys,
-                                                   &n);
-  if (!has_entries)
-    return;
+  if (!init_keys (keymap))
+    g_main_loop_quit (main_loop);
+}
 
-  keycodes = g_array_sized_new (TRUE, TRUE, sizeof (guint), n);
-  for (i = 0; i < n; ++i)
-    g_array_append_val (keycodes, keys[i].keycode);
+static void
+select_events (void)
+{
+  XIEventMask evmask;
+  unsigned char mask[(XI_LASTEVENT + 7)/8] = { 0 };
 
-  key->keycodes = (guint *) g_array_free (keycodes, FALSE);
+  XISetMask (mask, XI_RawButtonPress);
+  XISetMask (mask, XI_RawButtonRelease);
+  XISetMask (mask, XI_RawKeyPress);
+  XISetMask (mask, XI_RawKeyRelease);
 
-  gdk_x11_display_error_trap_push (display);
+  evmask.deviceid = XIAllMasterDevices;
+  evmask.mask_len = sizeof (mask);
+  evmask.mask = mask;
 
-  grab_key_unsafe (key, GSD_KEYGRAB_ALLOW_UNMODIFIED | GSD_KEYGRAB_SYNCHRONOUS, screens);
+  XISelectEvents (gdk_x11_get_default_xdisplay (),
+                  gdk_x11_get_default_root_xwindow (),
+                  &evmask,
+                  1);
 
-  gdk_x11_display_error_trap_pop_ignored (display);
+  gdk_window_add_filter (NULL, (GdkFilterFunc) filter, NULL);
 
-  g_free (keys);
+  g_signal_connect (gdk_keymap_get_default (), "keys-changed",
+                    G_CALLBACK (keys_changed), NULL);
 }
 
-static guint
-get_master_keyboard_id (GdkDisplay *display)
+static gboolean
+init_xkb (void)
 {
-  XIDeviceInfo *info;
-  guint id;
-  int i, n;
-
-  id = 0;
-  info = XIQueryDevice (GDK_DISPLAY_XDISPLAY (display), XIAllMasterDevices, &n);
-  for (i = 0; i < n; ++i)
-    if (info[i].use == XIMasterKeyboard && info[i].enabled)
-      {
-        id = info[i].deviceid;
-        break;
-      }
-  XIFreeDeviceInfo (info);
+  int major = XkbMajorVersion;
+  int minor = XkbMinorVersion;
 
-  return id;
+  if (!XkbLibraryVersion (&major, &minor) ||
+      !XkbQueryExtension (gdk_x11_get_default_xdisplay (), NULL, NULL, NULL, &major, &minor))
+    {
+      g_warning ("XKB not available, exiting");
+      return FALSE;
+    }
+
+  return TRUE;
 }
 
-static void
-set_input_sources_switcher (void)
+static gboolean
+init_xi2 (void)
 {
-  GdkDisplay *display;
-  gint n_screens;
-  GSList *screens, *l;
-  gint i;
+  int major, minor;
 
-  display = gdk_display_get_default ();
-  n_screens = gdk_display_get_n_screens (display);
-  screens = NULL;
-  for (i = 0; i < n_screens; ++i)
-    screens = g_slist_prepend (screens, gdk_display_get_screen (display, i));
-
-  for (i = 0; i < n_keys; ++i)
-    grab_key (&the_keys[i], display, screens);
+  /* required version to have raw events delivered regardless of grabs */
+  major = 2;
+  minor = 1;
 
-  for (l = screens; l; l = l->next)
+  gdk_error_trap_push ();
+  if (XIQueryVersion (gdk_x11_get_default_xdisplay (), &major, &minor) != Success)
     {
-      GdkScreen *screen;
-
-      screen = (GdkScreen *) l->data;
-      gdk_window_add_filter (gdk_screen_get_root_window (screen),
-                             (GdkFilterFunc) filter,
-                             screen);
+      /* try for 2.2, maybe gtk has already announced 2.2 support */
+      major = 2;
+      minor = 2;
+      if (XIQueryVersion (gdk_x11_get_default_xdisplay (), &major, &minor) != Success)
+        {
+          g_warning ("XI >= 2.1 not available, exiting");
+          return FALSE;
+        }
     }
+  gdk_error_trap_pop_ignored ();
 
-  g_slist_free (screens);
-
-  master_keyboard_id = get_master_keyboard_id (display);
+  return TRUE;
 }
 
 int
 main (int argc, char *argv[])
 {
-  gtk_init (&argc, &argv);
+  gdk_init (&argc, &argv);
+
+  if (!init_xkb () || !init_xi2 ())
+    return -1;
+
+  if (!init_keys (gdk_keymap_get_default ()))
+    return -1;
 
-  init_keys ();
-  if (n_keys == 0)
-    {
-      g_warning ("No shortcut defined, exiting");
-      return -1;
-    }
   input_sources_settings = g_settings_new (GNOME_DESKTOP_INPUT_SOURCES_DIR);
 
-  set_input_sources_switcher ();
-  gtk_main ();
+  select_events ();
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+  g_main_loop_run (main_loop);
+  g_main_loop_unref (main_loop);
 
   g_object_unref (input_sources_settings);
-  free_keys ();
+  g_hash_table_destroy (keycodes);
 
   return 0;
 }
-- 
1.8.0.1
